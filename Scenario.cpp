#include "Scenario.h"
#include "MetFileParser.h"
#include "Common.h"

#include <algorithm>
#include <iterator>
#include <numeric>
#include <fstream>

#include <boost/log/trivial.hpp>
#include <boost/log/attributes/scoped_attribute.hpp>

#include <fmt/format.h>

const std::map<int, std::string> Scenario::chemicalMap = {
    {0, "1,3-Dichloropropene"},
    {1, "Chloropicrin"},
    {2, "Chloropicrin + 1,3-Dichloropropene"},
    {3, "Chloropicrin + Methyl Bromide"},
    {4, "Metam Sodium / Metam Potassium / Dazomet"},
    {5, "Methyl Bromide"},
    {6, "Sulfuryl Fluoride"},
    {7, "Other"}
};

Scenario::Scenario()
{
    static unsigned int sequenceNumber = 1;
    id = sequenceNumber;
    sequenceNumber++;

    title = fmt::format("Run{:0=2}", id);
    fumigantId = 7; // Other
    decayCoefficient = 0;
    flagpoleHeight = 1.5;

    // Meteorological Data Defaults
    anemometerHeight = 10;
    windRotation = 0;

    // AERMOD Defaults
    aermodFlat = true;
    aermodFastArea = false;
    // Deposition
    aermodDryDeposition = false;
    aermodDryDplt = true;
    aermodAreaDplt = false;
    aermodWetDeposition = false;
    aermodWetDplt = true;
    // Defaults from PERFUM
    aermodGDSeasons = {4, 4, 5, 5, 5, 1, 1, 1, 2, 2, 2, 4};
    std::fill_n(aermodGDLandUse.begin(), 36, 2);
    // Gas Deposition
    aermodGDReact = 0;
    aermodGDSeasonF = {1.0, 0.5, 1.0, 1.0, 0.25};
    aermodGDVelocityEnabled = false;
    aermodGDVelocity = 0.01;
    aermodLowWind = false;
    aermodSVmin = 0.2;
    aermodWSmin = sqrt(2 * aermodSVmin * aermodSVmin);
    aermodFRANmax = 1.0;

    averagingPeriods = {1, 24};
}

void Scenario::resetSurfaceFileInfo()
{
    MetFileParser parser(surfaceFile);
    sfInfo = parser.getSurfaceInfo();

    if (sfInfo.tmin.is_not_a_date_time())
        return;

    if (sfInfo.tmax.is_not_a_date_time())
        return;

    // Construct QDateTime from boost::posix_time::ptime
    const boost::gregorian::date gdmin = sfInfo.tmin.date();
    const boost::gregorian::date gdmax = sfInfo.tmax.date();
    const boost::posix_time::time_duration ptmin = sfInfo.tmin.time_of_day();
    const boost::posix_time::time_duration ptmax = sfInfo.tmax.time_of_day();

    minTime = QDateTime(QDate(gdmin.year(), gdmin.month(), gdmin.day()),
                                  QTime(ptmin.hours(), 0, 0), Qt::UTC);
    maxTime = QDateTime(QDate(gdmax.year(), gdmax.month(), gdmax.day()),
                                  QTime(ptmax.hours(), 0, 0), Qt::UTC);

    surfaceId = sfInfo.sfloc;
    upperAirId = sfInfo.ualoc;
}

inline std::string aermodTimeString(const QDateTime& t)
{
    int hour = t.time().hour() + 1; // AERMOD uses 01-24
    QString hourPart = QString("%1").arg(hour, 2, 10, QChar('0'));
    QString timeStr = t.toString("yyyyMMdd") + hourPart;
    return timeStr.toStdString();
}

std::string Scenario::writeInput() const
{
    std::string krun = "RUN"; // RUNORNOT

    fmt::MemoryWriter w;

    w.write("** \n");
    w.write("** Generated by SOFEA " SOFEA_VERSION_STRING "\n");
    w.write("** \n");

    //-------------------------------------------------------------------------
    // Model Options
    //-------------------------------------------------------------------------

    // Create options string from flags.
    std::string options;

    // Determine ALPHA, NonDFAULT, DFAULT
    if (aermodLowWind)
        options.append("ALPHA CONC");
    else if (aermodFlat | aermodFastArea | aermodDryDeposition | aermodWetDeposition)
        options.append("CONC");
    else
        options.append("DFAULT CONC");

    // Deposition Options
    if (aermodDryDeposition & aermodWetDeposition)
        options.append(" DEPOS");
    if (aermodDryDeposition)
        options.append(" DDEP");
    if (aermodWetDeposition)
        options.append(" WDEP");

    // General Options
    if (aermodFlat)
        options.append(" FLAT");
    if (aermodFastArea)
        options.append(" FASTAREA");

    // Depletion Options
    if (aermodDryDeposition)
        aermodDryDplt ? options.append(" DRYDPLT")
                      : options.append(" NODRYDPLT");
    if (aermodWetDeposition)
        aermodWetDplt ? options.append(" WETDPLT")
                      : options.append(" NOWETDPLT");
    if (aermodDryDeposition & aermodDryDplt & aermodAreaDplt)
        options.append(" AREADPLT");

    //-------------------------------------------------------------------------
    // CONTROL Pathway
    //-------------------------------------------------------------------------

    w.write("CO STARTING\n");
    w.write("   MODELOPT {0}\n", options);
    if (aermodLowWind) {
        w.write("   LOW_WIND {:06.4f} {:06.4f} {:06.4f}\n", aermodSVmin, aermodWSmin, aermodFRANmax);
    }
    w.write("   FLAGPOLE {:<6.2f}\n", flagpoleHeight);
    w.write("   TITLEONE {}\n", title);
    if (averagingPeriods.size() > 0) {
        w.write("   AVERTIME");
        for (int i : averagingPeriods)
            w.write(" {}", i);
        w.write("\n");
    }
    w.write("   POLLUTID FUMIGANT\n");
    w.write("   DCAYCOEF {:G}\n", decayCoefficient);
    if (aermodDryDeposition & aermodGDVelocityEnabled & !aermodWetDeposition) {
        w.write("   GASDEPVD {:<1.4f}\n", aermodGDVelocity);
    }
    if (aermodDryDeposition & !aermodGDVelocityEnabled) {
        w.write("   GDSEASON");
        for (int i : aermodGDSeasons) {
            w.write(" {}", i);
        }
        w.write("\n");
        w.write("   GDLANUSE");
        for (int i : aermodGDLandUse) {
            w.write(" {}", i);
        }
        w.write("\n");
    }
    w.write("   RUNORNOT {}\n", krun);
    w.write("   ERRORFIL error.out\n");
    w.write("CO FINISHED\n\n");

    //-------------------------------------------------------------------------
    // SOURCE Pathway
    //-------------------------------------------------------------------------

    // These indexes are used to write out short source and source group
    // identifiers, because AERMOD only supports one hourly emissions
    // file per run.
    int isrc, igrp;

    w.write("SO STARTING\n");

    // Write parameters for each source.
    // LOCATION, SRCPARAM, AREAVERT, HOUREMIS, GASDEPOS, BUFRZONE
    isrc = 0;
    igrp = 0;
    for (const SourceGroup& sg : sourceGroups) {
        if (sg.sources.size() == 0)
            continue;

        w.write("** Source Group {} (G{:0=3})\n", sg.grpid, ++igrp);
        for (const Source& s : sg.sources)
        {
            // LOCATION, SRCPARAM, AREAVERT, HOUREMIS
            w << s.toString(++isrc);

            // GASDEPOS
            if ((aermodDryDeposition | aermodWetDeposition) &
                !aermodGDVelocityEnabled) {
                w.write("   GASDEPOS S{:0=3} {} {} {} {}\n", isrc,
                        s.airDiffusion, s.waterDiffusion,
                        s.cuticularResistance, s.henryConstant);
            }

            // BUFRZONE
            for (const std::pair<double, int>& z : sg.zones) {
                QDateTime zoneStart = s.appStart;
                QDateTime zoneEnd = zoneStart.addSecs(z.second * 60 * 60);
                w.write("   BUFRZONE S{:0=3} {: 8.2f} {} {}\n", isrc, z.first,
                        aermodTimeString(zoneStart), aermodTimeString(zoneEnd));
            }
        }
        w.write("\n");
    }

    // Write SRCGROUP for each source range.
    w.write("   SRCGROUP ALL\n");
    isrc = 0;
    igrp = 0;
    for (const SourceGroup& sg : sourceGroups) {
        if (sg.sources.size() == 0)
            continue;

        int isrc0 = ++isrc;
        isrc += sg.sources.size() - 1;
        w.write("   SRCGROUP G{:0=3} S{:0=3}-S{:0=3}\n", ++igrp, isrc0, isrc);
    }

    w.write("SO FINISHED\n\n");

    //-------------------------------------------------------------------------
    // RECEPTOR Pathway
    //-------------------------------------------------------------------------

    w.write("RE STARTING\n");
    igrp = 1;
    for (const SourceGroup& sg : sourceGroups) {
        // Receptor Grids
        int inet = 1;
        for (const ReceptorGrid& grid : sg.grids) {
            w.write("** Source Group {} (G{:0=3}), Grid C{:0=3}\n",
                    sg.grpid, igrp, inet);
            w.write("   GRIDCART G{:0=3}C{:0=3} STA\n", igrp, inet);
            w.write("   GRIDCART G{:0=3}C{:0=3} XYINC ", igrp, inet);
            w.write("{} {} {} ",  grid.xInit, grid.xCount, grid.xDelta);
            w.write("{} {} {}\n", grid.yInit, grid.yCount, grid.yDelta);
            w.write("   GRIDCART G{:0=3}C{:0=3} END\n", igrp, inet);
            inet++;
        }

        // Receptor Nodes
        if (sg.nodes.size() > 0) {
            w.write("** Source Group {} (G{:0=3}), Discrete\n", sg.grpid, igrp);
            for (const ReceptorNode& node : sg.nodes) {
                w.write("   DISCCART {: 10.2f} {: 10.2f} ", node.x, node.y);
                w.write("{: 6.2f} {: 6.2f}\n", node.zElev, node.zHill);
            }
        }

        // Receptor Rings
        int iarc = 1;
        for (const ReceptorRing& ring : sg.rings) {
            w.write("** Source Group {} (G{:0=3}), Ring R{:0=3}\n",
                    sg.grpid, igrp, iarc);
            w.write("** Distance = {}, Spacing = {}\n", ring.buffer, ring.spacing);
            for (const auto &p : ring.points) {
                w.write("   EVALCART {: 10.2f} {: 10.2f} ", p.x(), p.y());
                w.write("{: 6.2f} {: 6.2f} {: 6.2f} G{:0=3}R{:0=3}\n",
                        ring.zElev, ring.zHill, flagpoleHeight, igrp, iarc);
            }
            iarc++;
        }

        igrp++;
    }
    w.write("RE FINISHED\n\n");

    //-------------------------------------------------------------------------
    // METEOROLOGY Pathway
    //-------------------------------------------------------------------------

    QString startend;
    if (minTime.isValid() && maxTime.isValid())
        startend = minTime.toString("yy MM dd") + " " + maxTime.toString("yy MM dd");

    w.write("ME STARTING\n");
    w.write("   SURFFILE \"{}\"\n", surfaceFile);
    w.write("   PROFFILE \"{}\"\n", upperAirFile);
    w.write("   SURFDATA {} {}\n", surfaceId, minTime.date().year());
    w.write("   UAIRDATA {} {}\n", upperAirId, maxTime.date().year());
    w.write("   PROFBASE {: 6.1f} METERS\n", anemometerHeight);
    w.write("   STARTEND {}\n", startend.toStdString());
    w.write("   WDROTATE {: 5.1f}\n", windRotation);
    w.write("ME FINISHED\n\n");

    //-------------------------------------------------------------------------
    // OUTPUT Pathway
    //-------------------------------------------------------------------------

    w.write("OU STARTING\n");
    w.write("   RECTABLE ALLAVE FIRST\n");
    w.write("   SUMMFILE summary.txt\n");
    igrp = 1;
    for (const SourceGroup& sg : sourceGroups) {
        if (sg.sources.size() == 0)
            continue;

        for (int i : averagingPeriods)
            w.write("   POSTFILE {: =2} G{:0=3} NETCDF postfile.nc\n", i, igrp);

        igrp++;
    }

    for (int period : averagingPeriods)
        w.write("   POSTFILE {: =2} ALL  NETCDF postfile.nc\n", period);

    w.write("OU FINISHED\n");

    return w.str();
}

void Scenario::writeInputFile(const std::string& path) const
{
    std::ofstream ofs(path);
    ofs << writeInput();
    ofs.close();
}

void Scenario::writeFluxFile(const std::string& path) const
{
    BOOST_LOG_SCOPED_THREAD_TAG("Source", "Model");

    if (!minTime.isValid() || !maxTime.isValid()) {
        BOOST_LOG_TRIVIAL(error) << "Invalid time range";
        return;
    }

    // Make sure that each source has a valid flux profile.
    bool missingProfile = false;
    for (const SourceGroup &sg : sourceGroups) {
        for (const Source &s : sg.sources) {
            if (s.fluxProfile.expired()) {
                BOOST_LOG_TRIVIAL(error) << "Missing flux profile for source " << s.srcid;
                missingProfile = true;
            }
        }
    }

    if (missingProfile)
        return;

    fmt::MemoryWriter w;
    std::map<QDateTime, std::string> grid;

    // Construct the overall time grid.
    QDateTime t = minTime;
    while (t <= maxTime) {
        int hour = t.time().hour() + 1; // AERMOD uses 01-24
        QString hstr = QString(" %1").arg(hour, 2, 10, QChar('0'));
        QString tstr = t.toString("yy MM dd") + hstr;
        grid[t] = tstr.toStdString();
        t = t.addSecs(60 * 60);
    }

    // Generate and cache all expanded reference flux profiles.
    std::map<std::shared_ptr<FluxProfile>, std::vector<double>> exRefFluxMap;

    for (const auto fp : fluxProfiles)
    {
        // Expand the reference flux profile to one point per hour.
        std::vector<double> exRefFlux;
        for (const auto& xy : fp->refFlux) {
            std::fill_n(std::back_inserter(exRefFlux), xy.first, xy.second);
        }

        exRefFluxMap[fp] = exRefFlux;
    }

    // Determine the overall number of sources across source groups.
    int nsrc = 0;
    for (const SourceGroup& sg : sourceGroups)
        nsrc += sg.sources.size();

    // Initialize a vector with application started flag for each source.
    std::vector<bool> started(nsrc, false);

    // Initialize a vector with position in reference flux vector for each source.
    std::vector<int> index(nsrc, 0);

    // Write the flux profile for all sources. Must be in order of hour, then source.
    for (const auto& kv : grid)
    {
        // Initialize the source counter.
        int isrc = 0;

        for (const SourceGroup &sg : sourceGroups)
        {
            for (const Source &s : sg.sources)
            {
                const auto fp = s.fluxProfile.lock();
                if (!fp) {
                    BOOST_LOG_TRIVIAL(error) << "Failed to acquire read lock";
                    return;
                }

                // Calculate the overall flux scale factor.
                double sf = fp->fluxScaleFactor(s.appRate, s.appStart, s.incorpDepth);

                // Get the cached reference flux profile for this source.
                std::vector<double> exRefFlux = exRefFluxMap.at(fp);

                // Determine the number of hours in the expanded flux profile.
                int n = exRefFlux.size();

                // Calculate flux.
                double flux;
                if (kv.first == s.appStart) {
                    started[isrc] = true;
                }
                if (started[isrc] && index[isrc] < n) {
                    flux = exRefFlux[index[isrc]] * sf;
                    index[isrc]++;
                }
                else {
                    flux = 0;
                }

                // Write the SO HOUREMIS record and increment source counter.
                w.write("SO HOUREMIS {} S{:0=3} {: 8.6E}\n", kv.second, ++isrc, flux);
            }
        }
    }

    // Write the flux file.
    std::ofstream ofs(path);
    ofs << w.str();
    ofs.close();

    return;
}
